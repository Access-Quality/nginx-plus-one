name: ec5-plus

on:
  workflow_dispatch:

jobs:
  # ── 1. Create / update the cinex WAF policy in NGINX One Console ─────────────
  create-waf-policy-cinex:
    runs-on: ubuntu-latest
    env:
      XC_API_P12_FILE: ${{ secrets.XC_API_P12_FILE }}
      XC_API_URL: ${{ secrets.XC_API_URL }}
      VES_P12_PASSWORD: ${{ secrets.XC_P12_PASSWORD }}
      NGINX_ONE_NAMESPACE: default
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create NGINX One App Protect policy cinex (transparent)
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${XC_API_P12_FILE:-}" || -z "${XC_API_URL:-}" || -z "${VES_P12_PASSWORD:-}" ]]; then
            echo "Missing one or more required secrets: XC_API_P12_FILE, XC_API_URL, XC_P12_PASSWORD" >&2
            exit 1
          fi

          workdir="$(mktemp -d)"
          trap 'rm -rf "$workdir"' EXIT
          cd "$workdir"

          api_url_raw="$(printf '%s' "$XC_API_URL" | tr -d '\r\n')"
          api_url="$api_url_raw"
          if [[ "$api_url" != http://* && "$api_url" != https://* ]]; then
            api_url="https://$api_url"
          fi
          if [[ "$api_url" == */api/* ]]; then
            api_url="${api_url%%/api/*}/api"
          elif [[ "$api_url" != */api ]]; then
            api_url="${api_url%/}/api"
          fi
          echo "Using XC API URL: $api_url"

          if ! printf '%s' "$XC_API_P12_FILE" | base64 --decode > api.p12 2>/dev/null; then
            echo "XC_API_P12_FILE does not look like base64; writing it as-is to api.p12" >&2
            printf '%s' "$XC_API_P12_FILE" > api.p12
          fi

          openssl_conf="$workdir/openssl.cnf"
          cat > "$openssl_conf" <<'EOF'
          openssl_conf = openssl_init

          [openssl_init]
          providers = provider_sect

          [provider_sect]
          default = default_sect
          legacy = legacy_sect

          [default_sect]
          activate = 1

          [legacy_sect]
          activate = 1
          EOF

          export OPENSSL_CONF="$openssl_conf"
          for d in /usr/lib/x86_64-linux-gnu/ossl-modules /usr/lib/ssl/ossl-modules /usr/local/lib/ossl-modules; do
            if [[ -d "$d" ]]; then
              export OPENSSL_MODULES="$d"
              break
            fi
          done

          if ! openssl pkcs12 -in api.p12 -passin pass:"$VES_P12_PASSWORD" -nodes -nokeys >/dev/null 2>&1; then
            echo "Failed to read PKCS#12 bundle. Check XC_P12_PASSWORD." >&2
            exit 1
          fi

          nginx_one_base_url="${api_url%/}/nginx/one/namespaces/${NGINX_ONE_NAMESPACE}"
          policies_url="${nginx_one_base_url}/app-protect/policies"
          echo "Using NGINX One policies URL: ${policies_url}"

          policy_src="${GITHUB_WORKSPACE}/ex5-plus/scripts/cinex-policy.json"
          if [[ ! -f "$policy_src" ]]; then
            echo "Missing policy file: $policy_src" >&2
            exit 1
          fi
          cp "$policy_src" cinex-policy.json

          existing_json="$workdir/existing.json"
          curl -fsS \
            --cert-type P12 \
            --cert "./api.p12:${VES_P12_PASSWORD}" \
            --get \
            --data-urlencode "paginated=false" \
            --data-urlencode "filter_fields=name" \
            --data-urlencode "filter_ops=IN" \
            --data-urlencode "filter_values=cinex" \
            "${policies_url}" \
            > "$existing_json" || true

          policy_object_id=""
          if [[ -f "$existing_json" ]]; then
            policy_object_id="$(python3 -c 'import json,sys; data=json.load(open(sys.argv[1],"r",encoding="utf-8")); items=data.get("items") or []; print(next((i.get("object_id","") for i in items if i.get("name")=="cinex"), ""))' "$existing_json" 2>/dev/null || true)"
          fi

          policy_b64="$(base64 < cinex-policy.json | tr -d '\n')"
          create_body="{\"policy\":\"${policy_b64}\"}"

          if [[ -n "$policy_object_id" ]]; then
            echo "Policy 'cinex' exists (object_id=$policy_object_id); creating a new version via PUT"
            curl -fsS \
              --cert-type P12 \
              --cert "./api.p12:${VES_P12_PASSWORD}" \
              -H "Content-Type: application/json" \
              -X PUT \
              -d "$create_body" \
              "${policies_url}/${policy_object_id}" \
              > /tmp/nginx-one-cinex-update.json
            echo "Updated policy (response):"
            cat /tmp/nginx-one-cinex-update.json
          else
            echo "Creating NGINX One App Protect policy 'cinex'"
            curl -fsS \
              --cert-type P12 \
              --cert "./api.p12:${VES_P12_PASSWORD}" \
              -H "Content-Type: application/json" \
              -X POST \
              -d "$create_body" \
              "${policies_url}" \
              > /tmp/nginx-one-cinex-create.json
            echo "Created policy (response):"
            cat /tmp/nginx-one-cinex-create.json
          fi

  # ── 2. TFC workspace setup ────────────────────────────────────────────────────
  setup-tfc:
    runs-on: ubuntu-latest
    env:
      TFC_TOKEN: ${{ secrets.TFC_TOKEN }}
      TFC_ORG: ${{ secrets.TFC_ORG }}
    outputs:
      tf_workspace: ${{ steps.set-outputs.outputs.tf_workspace }}
      name_prefix: ${{ steps.set-outputs.outputs.name_prefix }}
      ssh_cidr: ${{ steps.set-outputs.outputs.ssh_cidr }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
          cli_config_credentials_token: ${{ secrets.TFC_TOKEN }}

      - name: Set dynamic vars
        shell: bash
        run: |
          set -euo pipefail
          repo_name="${GITHUB_REPOSITORY##*/}"
          # ec5-plus- prefix differentiates workspaces from nginx-plus-ec2
          echo "TFC_WORKSPACE=ec5-plus-$repo_name" >> "$GITHUB_ENV"
          echo "TF_WORKSPACE=ec5-plus-$repo_name"  >> "$GITHUB_ENV"
          echo "NAME_PREFIX=ec5-plus-$repo_name"   >> "$GITHUB_ENV"
          echo "SSH_CIDR=0.0.0.0/0"                >> "$GITHUB_ENV"

      - name: Ensure TFC workspace
        shell: bash
        run: |
          set -euo pipefail
          status=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TFC_TOKEN" \
            "https://app.terraform.io/api/v2/organizations/$TFC_ORG/workspaces/$TFC_WORKSPACE")

          if [[ "$status" == "404" ]]; then
            curl -sS -X POST \
              -H "Authorization: Bearer $TFC_TOKEN" \
              -H "Content-Type: application/vnd.api+json" \
              -d "{\"data\":{\"type\":\"workspaces\",\"attributes\":{\"name\":\"$TFC_WORKSPACE\",\"execution-mode\":\"local\"}}}" \
              "https://app.terraform.io/api/v2/organizations/$TFC_ORG/workspaces"
          elif [[ "$status" != "200" ]]; then
            echo "Unexpected status from TFC: $status" >&2
            exit 1
          fi

      - name: Set job outputs
        id: set-outputs
        shell: bash
        run: |
          set -euo pipefail
          repo_name="${GITHUB_REPOSITORY##*/}"
          echo "tf_workspace=ec5-plus-$repo_name" >> "$GITHUB_OUTPUT"
          echo "name_prefix=ec5-plus-$repo_name"  >> "$GITHUB_OUTPUT"
          echo "ssh_cidr=0.0.0.0/0"               >> "$GITHUB_OUTPUT"

  # ── 3. Provision EC2 instances via Terraform ──────────────────────────────────
  terraform:
    needs: setup-tfc
    runs-on: ubuntu-latest
    env:
      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"
      TFC_TOKEN: ${{ secrets.TFC_TOKEN }}
      TFC_ORG: ${{ secrets.TFC_ORG }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      TF_WORKSPACE: ${{ needs.setup-tfc.outputs.tf_workspace }}
      NAME_PREFIX: ${{ needs.setup-tfc.outputs.name_prefix }}
      SSH_CIDR: ${{ needs.setup-tfc.outputs.ssh_cidr }}
      SSH_PUBLIC_KEY: ${{ secrets.SSH_PUBLIC_KEY }}
    outputs:
      public_ip: ${{ steps.ip.outputs.public_ip }}
      cine_private_ip: ${{ steps.ip.outputs.cine_private_ip }}
      cine_public_ip: ${{ steps.ip.outputs.cine_public_ip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write SSH public key for Terraform
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${SSH_PUBLIC_KEY:-}" ]]; then
            echo "Missing SSH_PUBLIC_KEY secret" >&2
            exit 1
          fi
          printf '%s\n' "$SSH_PUBLIC_KEY" > /tmp/ssh_key.pub

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
          cli_config_credentials_token: ${{ secrets.TFC_TOKEN }}

      - name: Terraform init
        working-directory: ex5-plus/terraform/nginx-plus-ec2
        run: |
          terraform init \
            -backend-config="organization=$TFC_ORG"

      - name: Terraform plan
        working-directory: ex5-plus/terraform/nginx-plus-ec2
        run: |
          terraform plan -out=/tmp/tfplan \
            -var="aws_region=$AWS_REGION" \
            -var="ssh_cidr=$SSH_CIDR" \
            -var="name_prefix=$NAME_PREFIX" \
            -var="ssh_public_key=$(cat /tmp/ssh_key.pub)"

      - name: Save terraform plan (JSON)
        working-directory: ex5-plus/terraform/nginx-plus-ec2
        run: |
          set -euo pipefail
          terraform show -json /tmp/tfplan > /tmp/tfplan.json || true

      - name: Upload terraform plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: ec5-plus-terraform-plan
          path: /tmp/tfplan.json
          if-no-files-found: warn

      - name: Terraform apply
        working-directory: ex5-plus/terraform/nginx-plus-ec2
        run: |
          terraform apply -auto-approve /tmp/tfplan

      - name: Get instance IPs
        id: ip
        working-directory: ex5-plus/terraform/nginx-plus-ec2
        run: |
          echo "public_ip=$(terraform output -raw public_ip)"             >> "$GITHUB_OUTPUT"
          echo "cine_private_ip=$(terraform output -raw cine_private_ip)" >> "$GITHUB_OUTPUT"
          echo "cine_public_ip=$(terraform output -raw cine_public_ip)"   >> "$GITHUB_OUTPUT"

      - name: Cleanup SSH public key file
        shell: bash
        run: rm -f /tmp/ssh_key.pub || true

  # ── 4. Install NGINX Plus + NAP v5 (Docker) + Agent 3.x ──────────────────────
  install:
    needs: [terraform, setup-tfc]
    runs-on: ubuntu-latest
    env:
      NGINX_REPO_CRT: ${{ secrets.NGINX_REPO_CRT }}
      NGINX_REPO_KEY: ${{ secrets.NGINX_REPO_KEY }}
      LICENSE_JWT: ${{ secrets.LICENSE_JWT }}
      LICENSE_KEY: ${{ secrets.LICENSE_KEY }}
      DATA_PLANE_KEY: ${{ secrets.DATA_PLANE_KEY }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare SSH key
        run: |
          set -euo pipefail
          if [[ -z "${SSH_PRIVATE_KEY:-}" ]]; then
            echo "Missing SSH_PRIVATE_KEY secret" >&2
            exit 1
          fi
          mkdir -p ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -T 10 -H "${{ needs.terraform.outputs.public_ip }}" >> ~/.ssh/known_hosts || true

      - name: Wait for SSH
        run: |
          set -euo pipefail
          for i in {1..30}; do
            if ssh -o BatchMode=yes -o ConnectTimeout=5 \
              -o StrictHostKeyChecking=accept-new \
              ubuntu@${{ needs.terraform.outputs.public_ip }} "true"; then
              exit 0
            fi
            sleep 10
          done
          echo "SSH not reachable after waiting." >&2
          exit 1

      - name: Upload NGINX credentials
        run: |
          set -euo pipefail
          BASTION="${{ needs.terraform.outputs.public_ip }}"
          if [[ -z "$NGINX_REPO_CRT" || -z "$NGINX_REPO_KEY" ]]; then
            echo "Missing NGINX repo cert/key secrets." >&2
            exit 1
          fi
          printf '%s' "$NGINX_REPO_CRT" > /tmp/nginx-repo.crt
          printf '%s' "$NGINX_REPO_KEY" > /tmp/nginx-repo.key
          printf '%s' "$LICENSE_JWT"    > /tmp/license.jwt
          printf '%s' "$LICENSE_KEY"    > /tmp/license.key

          ssh_opts=(-o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 -o ServerAliveInterval=10 -o ServerAliveCountMax=3)

          scp_retry() {
            local src="$1" dst="$2" attempt
            for attempt in {1..12}; do
              if scp "${ssh_opts[@]}" "$src" "$dst"; then return 0; fi
              echo "SCP failed (attempt ${attempt}/12). Retrying in 10s..." >&2
              sleep 10
            done
            echo "SCP failed after 12 attempts: $src -> $dst" >&2
            return 1
          }

          ssh "${ssh_opts[@]}" "ubuntu@${BASTION}" "true"
          scp_retry /tmp/nginx-repo.crt "ubuntu@${BASTION}:/tmp/nginx-repo.crt"
          scp_retry /tmp/nginx-repo.key "ubuntu@${BASTION}:/tmp/nginx-repo.key"
          scp_retry /tmp/license.jwt    "ubuntu@${BASTION}:/tmp/license.jwt"
          scp_retry /tmp/license.key    "ubuntu@${BASTION}:/tmp/license.key"

      - name: Upload docker-compose and WAF policy for waf-config-mgr
        run: |
          set -euo pipefail
          BASTION="${{ needs.terraform.outputs.public_ip }}"

          # docker-compose.yaml is uploaded to /tmp so install script can place it in /opt/nap-v5/
          scp ex5-plus/scripts/docker-compose.yaml "ubuntu@${BASTION}:/tmp/docker-compose.yaml"

          # cinex-policy.json must be in /opt/app_protect/config/ *before* waf-config-mgr starts
          # so the container finds it on startup and compiles cinex.tgz immediately.
          ssh "ubuntu@${BASTION}" 'bash -s' <<'EOF'
          set -euo pipefail
          sudo mkdir -p /opt/app_protect/config /opt/app_protect/bd_config
          sudo chown -R 101:101 /opt/app_protect
          EOF

          scp ex5-plus/scripts/cinex-policy.json "ubuntu@${BASTION}:/tmp/cinex-policy.json"
          ssh "ubuntu@${BASTION}" \
            "sudo cp /tmp/cinex-policy.json /opt/app_protect/config/cinex.json && \
             sudo chown 101:101 /opt/app_protect/config/cinex.json && \
             sudo chmod 0644   /opt/app_protect/config/cinex.json && \
             rm -f /tmp/cinex-policy.json"

      - name: Clear apt locks (safe on re-run)
        run: |
          ssh ubuntu@${{ needs.terraform.outputs.public_ip }} 'bash -s' <<'EOF'
          set -euo pipefail
          sudo rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock || true
          sudo dpkg --configure -a || true
          EOF

      - name: Install NGINX Plus + NAP v5 + Agent 3.x
        run: |
          set -euo pipefail
          scp ex5-plus/scripts/install-nginx-plus.sh \
            ubuntu@${{ needs.terraform.outputs.public_ip }}:/tmp/install-nginx-plus.sh
          ssh ubuntu@${{ needs.terraform.outputs.public_ip }} \
            "sudo DATA_PLANE_KEY='$DATA_PLANE_KEY' LICENSE_JWT='$LICENSE_JWT' \
             bash /tmp/install-nginx-plus.sh"

      - name: Upload and apply App Protect policy to /etc/app_protect
        run: |
          set -euo pipefail
          BASTION="${{ needs.terraform.outputs.public_ip }}"
          # Also place in /etc/app_protect/conf/ for the security log profile reference
          ssh "ubuntu@${BASTION}" \
            "sudo mkdir -p /etc/app_protect/conf && \
             sudo cp /opt/app_protect/config/cinex.json /etc/app_protect/conf/cinex.json && \
             sudo chown root:root /etc/app_protect/conf/cinex.json && \
             sudo chmod 0644 /etc/app_protect/conf/cinex.json"

      - name: Configure NGINX vhosts for Cine apps (NAP v5)
        run: |
          set -euo pipefail
          BASTION="${{ needs.terraform.outputs.public_ip }}"
          CINE_PRIVATE="${{ needs.terraform.outputs.cine_private_ip }}"

          cp ex5-plus/scripts/cine-nginx.conf /tmp/cine-nginx.conf
          sed -i "s/CINE_IP_PLACEHOLDER/${CINE_PRIVATE}/g" /tmp/cine-nginx.conf
          scp /tmp/cine-nginx.conf "ubuntu@${BASTION}:/tmp/cine-nginx.conf"

          ssh "ubuntu@${BASTION}" 'bash -s' <<'EOF'
          set -euo pipefail

          sudo rm -f /etc/nginx/conf.d/default.conf /etc/nginx/sites-enabled/default || true

          sudo mv /tmp/cine-nginx.conf /etc/nginx/conf.d/cine.conf
          sudo chown root:root /etc/nginx/conf.d/cine.conf
          sudo chmod 0644 /etc/nginx/conf.d/cine.conf

          # Remove any competing default_server on port 80
          for f in /etc/nginx/conf.d/*.conf /etc/nginx/sites-enabled/*; do
            [[ -e "$f" ]] || continue
            [[ "$f" == "/etc/nginx/conf.d/cine.conf" ]] && continue
            if sudo grep -Eq 'listen\s+80([^;]*)default_server' "$f"; then
              echo "Removing competing default_server config: $f" >&2
              sudo rm -f "$f"
            fi
          done

          sudo nginx -t
          sudo systemctl reload nginx
          sudo systemctl restart nginx-agent || true
          EOF

      - name: Validate WAF v5 runtime and NGINX config
        run: |
          set -euo pipefail
          BASTION="${{ needs.terraform.outputs.public_ip }}"
          CINE_PRIVATE="${{ needs.terraform.outputs.cine_private_ip }}"

          ssh "ubuntu@${BASTION}" "CINE_PRIVATE='${CINE_PRIVATE}' bash -s" <<'EOF'
          set -euo pipefail

          echo "=== OS ==="
          lsb_release -a

          echo "=== Installed packages ==="
          dpkg -l | awk '$2 ~ /nginx-plus|app-protect/ {print $2, $3}'

          echo "=== NGINX Agent version ==="
          nginx-agent --version 2>/dev/null || true

          echo "=== Docker containers (NAP v5 runtime) ==="
          sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          # Must have waf-enforcer and waf-config-mgr running
          sudo docker ps --format "{{.Names}}" | grep -q "waf-enforcer"
          sudo docker ps --format "{{.Names}}" | grep -q "waf-config-mgr"
          echo "Both NAP v5 containers are running."

          echo "=== Policy bundle compiled by waf-config-mgr ==="
          if [[ -f /opt/app_protect/bd_config/cinex.tgz ]]; then
            ls -lh /opt/app_protect/bd_config/cinex.tgz
          else
            echo "WARNING: /opt/app_protect/bd_config/cinex.tgz not found" >&2
          fi

          echo "=== /opt/app_protect permissions ==="
          ls -la /opt/app_protect/

          echo "=== NGINX config validation ==="
          sudo nginx -T > /tmp/nginx-full.conf 2>/tmp/nginx-test.err
          grep -q "load_module modules/ngx_http_app_protect_module.so;" /tmp/nginx-full.conf
          grep -q "app_protect_enforcer_address 127.0.0.1:50000;" /tmp/nginx-full.conf
          grep -q "app_protect_enable on;" /tmp/nginx-full.conf
          grep -q "app_protect_security_log_enable on;" /tmp/nginx-full.conf
          grep -q "syslog:server=127.0.0.1:5140" /tmp/nginx-full.conf
          grep -q "api write=on;" /tmp/nginx-full.conf
          echo "All required NGINX directives present."

          echo "=== Vhost quick check ==="
          curl -sS -o /dev/null -w "cine.example.com -> HTTP %{http_code}\n" \
            -H "Host: cine.example.com" http://127.0.0.1/ || true
          curl -sS -o /dev/null -w "cine-tmdb.example.com -> HTTP %{http_code}\n" \
            -H "Host: cine-tmdb.example.com" http://127.0.0.1/ || true

          echo "=== NGINX error log (last 30 lines) ==="
          sudo tail -n 30 /var/log/nginx/error.log | grep -E "APP_PROTECT|app_protect|emerg|crit" || true
          EOF

      - name: Cleanup temporary keys and secrets
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if command -v shred >/dev/null 2>&1; then
            shred -u ~/.ssh/id_rsa || true
            shred -u /tmp/nginx-repo.crt /tmp/nginx-repo.key /tmp/license.jwt /tmp/license.key || true
            shred -u /tmp/tfplan /tmp/tfplan.json /tmp/cine-nginx.conf || true
          else
            rm -f ~/.ssh/id_rsa || true
            rm -f /tmp/nginx-repo.crt /tmp/nginx-repo.key /tmp/license.jwt /tmp/license.key || true
            rm -f /tmp/tfplan /tmp/tfplan.json /tmp/cine-nginx.conf || true
          fi

  # ── 5. Build & validate Cine app artifacts ────────────────────────────────────
  build-cine-omdb:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate OMDB app syntax
        run: node --check ex5-plus/scripts/cine-app.js

      - name: Upload OMDB app artifact
        uses: actions/upload-artifact@v4
        with:
          name: ec5-plus-cine-omdb-bundle
          path: |
            ex5-plus/scripts/cine-app.js
            ex5-plus/scripts/cine.service

  build-cine-tmdb:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate TMDB app syntax
        run: node --check ex5-plus/scripts/cine-tmdb-app.js

      - name: Upload TMDB app artifact
        uses: actions/upload-artifact@v4
        with:
          name: ec5-plus-cine-tmdb-bundle
          path: |
            ex5-plus/scripts/cine-tmdb-app.js
            ex5-plus/scripts/cine-tmdb.service

  # ── 6. Deploy Cine apps to the backend instance ───────────────────────────────
  deploy-cine:
    needs: [terraform, setup-tfc, install, build-cine-omdb, build-cine-tmdb, create-waf-policy-cinex]
    runs-on: ubuntu-latest
    env:
      OMDB_API_KEY: ${{ secrets.OMDB_API_KEY }}
      TMDB_API_KEY: ${{ secrets.TMDB_API_KEY }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    steps:
      - name: Download OMDB artifact
        uses: actions/download-artifact@v4
        with:
          name: ec5-plus-cine-omdb-bundle
          path: /tmp/cine-omdb

      - name: Download TMDB artifact
        uses: actions/download-artifact@v4
        with:
          name: ec5-plus-cine-tmdb-bundle
          path: /tmp/cine-tmdb

      - name: Prepare SSH key
        run: |
          set -euo pipefail
          if [[ -z "${SSH_PRIVATE_KEY:-}" ]]; then
            echo "Missing SSH_PRIVATE_KEY secret" >&2
            exit 1
          fi
          mkdir -p ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -T 10 -H "${{ needs.terraform.outputs.cine_public_ip }}" >> ~/.ssh/known_hosts || true

      - name: Wait for SSH
        run: |
          set -euo pipefail
          for i in {1..30}; do
            if ssh -o BatchMode=yes -o ConnectTimeout=5 \
              -o StrictHostKeyChecking=accept-new \
              ubuntu@${{ needs.terraform.outputs.cine_public_ip }} "true"; then
              exit 0
            fi
            sleep 10
          done
          echo "SSH not reachable after waiting." >&2
          exit 1

      - name: Install Node.js 20
        run: |
          ssh ubuntu@${{ needs.terraform.outputs.cine_public_ip }} \
            "curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - && \
             sudo apt-get install -y nodejs"

      - name: Resolve artifact paths
        run: |
          set -euo pipefail
          OMDB_APP_PATH="$(find /tmp/cine-omdb -type f -name 'cine-app.js' | head -n1)"
          OMDB_SVC_PATH="$(find /tmp/cine-omdb -type f -name 'cine.service' | head -n1)"
          TMDB_APP_PATH="$(find /tmp/cine-tmdb -type f -name 'cine-tmdb-app.js' | head -n1)"
          TMDB_SVC_PATH="$(find /tmp/cine-tmdb -type f -name 'cine-tmdb.service' | head -n1)"

          if [[ -z "$OMDB_APP_PATH" || -z "$OMDB_SVC_PATH" || -z "$TMDB_APP_PATH" || -z "$TMDB_SVC_PATH" ]]; then
            echo "Artifact files not found after download" >&2
            find /tmp/cine-omdb /tmp/cine-tmdb -maxdepth 5 -type f -print || true
            exit 1
          fi

          echo "OMDB_APP_PATH=${OMDB_APP_PATH}" >> "$GITHUB_ENV"
          echo "OMDB_SVC_PATH=${OMDB_SVC_PATH}" >> "$GITHUB_ENV"
          echo "TMDB_APP_PATH=${TMDB_APP_PATH}" >> "$GITHUB_ENV"
          echo "TMDB_SVC_PATH=${TMDB_SVC_PATH}" >> "$GITHUB_ENV"

      - name: Deploy Cine apps
        run: |
          set -euo pipefail
          CINE="${{ needs.terraform.outputs.cine_public_ip }}"
          scp "$OMDB_APP_PATH" "ubuntu@${CINE}:/tmp/app.js"
          scp "$OMDB_SVC_PATH" "ubuntu@${CINE}:/tmp/cine.service"
          scp "$TMDB_APP_PATH" "ubuntu@${CINE}:/tmp/cine-tmdb-app.js"
          scp "$TMDB_SVC_PATH" "ubuntu@${CINE}:/tmp/cine-tmdb.service"

          ssh "ubuntu@${CINE}" \
            "sudo mkdir -p /opt/cine /etc/cine /opt/cine-tmdb /etc/cine-tmdb && \
             sudo mv /tmp/app.js /opt/cine/app.js && \
             sudo mv /tmp/cine-tmdb-app.js /opt/cine-tmdb/app.js && \
             sudo chown -R ubuntu:ubuntu /opt/cine /opt/cine-tmdb && \
             echo \"OMDB_API_KEY=$OMDB_API_KEY\" | sudo tee /etc/cine/cine.env >/dev/null && \
             echo \"TMDB_API_KEY=$TMDB_API_KEY\" | sudo tee /etc/cine-tmdb/cine-tmdb.env >/dev/null && \
             sudo chmod 600 /etc/cine/cine.env /etc/cine-tmdb/cine-tmdb.env"

      - name: Start Cine services
        run: |
          CINE="${{ needs.terraform.outputs.cine_public_ip }}"
          ssh "ubuntu@${CINE}" \
            "sudo mv /tmp/cine.service /etc/systemd/system/cine.service && \
             sudo mv /tmp/cine-tmdb.service /etc/systemd/system/cine-tmdb.service && \
             sudo systemctl daemon-reload && \
             sudo systemctl enable cine cine-tmdb && \
             sudo systemctl start cine cine-tmdb && \
             sudo systemctl status cine cine-tmdb"

      - name: Verify Cine apps are running
        run: |
          ssh ubuntu@${{ needs.terraform.outputs.cine_public_ip }} 'bash -s' <<'EOF'
          set -euo pipefail
          echo "=== Service status ==="
          sudo systemctl status cine cine-tmdb
          echo "=== Port listening ==="
          sudo ss -tlnp | grep -E ':3000|:3001' || \
            (echo "ERROR: ports 3000/3001 not listening" >&2; exit 1)
          echo "=== Recent logs ==="
          sudo journalctl -u cine     -n 15 --no-pager
          sudo journalctl -u cine-tmdb -n 15 --no-pager
          echo "=== Node.js version ==="
          node --version
          EOF

      - name: Display app URLs
        run: |
          echo "Cine (OMDB) app:  http://${{ needs.terraform.outputs.cine_public_ip }}:3000/"
          echo "Cine (TMDB) app:  http://${{ needs.terraform.outputs.cine_public_ip }}:3001/"
          echo "NGINX Plus proxy: ${{ needs.terraform.outputs.public_ip }}"
          echo "  Host: cine.example.com       -> Cine OMDB (NAP v5 WAF)"
          echo "  Host: cine-tmdb.example.com  -> Cine TMDB (NAP v5 WAF)"

      - name: Cleanup SSH key
        if: always()
        shell: bash
        run: |
          if command -v shred >/dev/null 2>&1; then
            shred -u ~/.ssh/id_rsa || true
          else
            rm -f ~/.ssh/id_rsa || true
          fi
